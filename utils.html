<!DOCTYPE html><html lang="en"><head><title>utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="utils"><meta name="groc-project-path" content="lib/utils.coffee"><meta name="groc-github-url" content="https://github.com/nevir/groc"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/nevir/groc/blob/master/lib/utils.coffee">lib/utils.coffee</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Miscellaneous code fragments reside here.</p>

<p>TODO: should be migrated into <code>lib/utils</code>.</p></div></div><div class="code"><div class="wrapper"><span class="nv">childProcess = </span><span class="nx">require</span> <span class="s">&#39;child_process&#39;</span>
<span class="nv">path         = </span><span class="nx">require</span> <span class="s">&#39;path&#39;</span>

<span class="nv">_        = </span><span class="nx">require</span> <span class="s">&#39;underscore&#39;</span>
<span class="nv">showdown = </span><span class="nx">require</span> <span class="s">&#39;showdown&#39;</span>

<span class="nv">CompatibilityHelpers = </span><span class="nx">require</span> <span class="s">&#39;./utils/compatibility_helpers&#39;</span>
<span class="nv">LANGUAGES            = </span><span class="kc">null</span>
<span class="nv">DOC_TAGS             = </span><span class="nx">require</span> <span class="s">&#39;./doc_tags&#39;</span>
<span class="nv">Logger               = </span><span class="nx">require</span> <span class="s">&#39;./utils/logger&#39;</span>


<span class="nv">module.exports = Utils =</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Code from <a href="http://zetafleet.com/">http://zetafleet.com/</a>
via <a href="http://blog.simonwillison.net/post/57956816139/escape">http://blog.simonwillison.net/post/57956816139/escape</a></p></div></div><div class="code"><div class="wrapper">  <span class="nv">regexpEscapePattern : </span><span class="sr">/[-[\]{}()*+?.,\\^$|#\s]/g</span>
  <span class="nv">regexpEscapeReplace : </span><span class="s">&#39;\\$&amp;&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Escape regular expression characters in a String, an Array of Strings or
any Object having a proper toString-method</p></div></div><div class="code"><div class="wrapper">  <span class="nv">regexpEscape: </span><span class="nf">(obj) -&gt;</span>
    <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isArray</span> <span class="nx">obj</span>
      <span class="nx">_</span><span class="p">.</span><span class="nx">invoke</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s">&#39;replace&#39;</span><span class="p">,</span> <span class="nx">@regexpEscapePattern</span><span class="p">,</span> <span class="nx">@regexpEscapeReplace</span><span class="p">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isString</span> <span class="nx">obj</span>
      <span class="nx">obj</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">@regexpEscapePattern</span><span class="p">,</span> <span class="nx">@regexpEscapeReplace</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="nx">@regexpEscape</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">obj</span><span class="si">}</span><span class="s">&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detect and return the language that a given file is written in.
The language is also annotated with a name property, matching the language's
key in LANGUAGES.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getLanguage: </span><span class="nf">(filePath, languageDefinitions = &#39;./languages&#39;) -&gt;</span>
    <span class="k">unless</span> <span class="nx">@_languageDetectionCache</span><span class="o">?</span>
      <span class="vi">@_languageDetectionCache = </span><span class="p">[]</span>

      <span class="nv">LANGUAGES = </span><span class="nx">require</span><span class="p">(</span><span class="nx">languageDefinitions</span><span class="p">)</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">LANGUAGES</span><span class="o">?</span>

      <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">language</span> <span class="k">of</span> <span class="nx">LANGUAGES</span>
        <span class="nv">language.name = </span><span class="nx">name</span>

        <span class="k">for</span> <span class="nx">matcher</span> <span class="k">in</span> <span class="nx">language</span><span class="p">.</span><span class="nx">nameMatchers</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the matcher is a string, we assume that it's a file extension.
Stick it in a regex:</p></div></div><div class="code"><div class="wrapper">          <span class="nv">matcher = </span><span class="sr">///</span><span class="si">#{</span><span class="nx">@regexpEscape</span> <span class="nx">matcher</span><span class="si">}</span><span class="sr">$///</span> <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isString</span> <span class="nx">matcher</span>

          <span class="nx">@_languageDetectionCache</span><span class="p">.</span><span class="nx">push</span> <span class="p">[</span><span class="nx">matcher</span><span class="p">,</span> <span class="nx">language</span><span class="p">]</span>

    <span class="nv">baseName = </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span> <span class="nx">filePath</span>

    <span class="k">for</span> <span class="nx">pair</span> <span class="k">in</span> <span class="nx">@_languageDetectionCache</span>
      <span class="k">return</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nx">baseName</span><span class="p">.</span><span class="nx">match</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map a list of file paths to relative target paths by stripping prefixes.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">mapFiles: </span><span class="nf">(resolveRoot, files, stripPrefixes) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure that we're dealing with absolute paths across the board.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">files = </span><span class="nx">files</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(f) -&gt;</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span> <span class="nx">resolveRoot</span><span class="p">,</span> <span class="nx">f</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>And that the strip prefixes all end with a /, avoids absolute target path.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">stripPrefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(p) -&gt;</span>
      <span class="nx">path</span><span class="p">.</span><span class="nx">join</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span> <span class="nx">resolveRoot</span><span class="p">,</span> <span class="nx">p</span><span class="si">}#{</span><span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">pathSep</span><span class="si">}</span><span class="s">&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prefixes are stripped in the order of most specific to least
(# of directories deep)</p></div></div><div class="code"><div class="wrapper">    <span class="nv">prefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">sort</span> <span class="nf">(a,b) =&gt;</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="nv">result = </span><span class="p">{}</span>

    <span class="k">for</span> <span class="nx">absPath</span> <span class="k">in</span> <span class="nx">files</span>
      <span class="nv">file = </span><span class="nx">absPath</span>

      <span class="k">for</span> <span class="nx">stripPath</span> <span class="k">in</span> <span class="nx">stripPrefixes</span>
        <span class="nv">file = </span><span class="nx">file</span><span class="p">[</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">..]</span> <span class="k">if</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">is</span> <span class="nx">stripPath</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We also strip the extension under the assumption that the consumer of
this path map is going to substitute in their own.  Plus, if they care
about the extension, they can get it from the keys of the map.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">result</span><span class="p">[</span><span class="nx">absPath</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="k">then</span> <span class="nx">file</span> <span class="k">else</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="o">-</span><span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">).</span><span class="nx">length</span><span class="p">]</span>

    <span class="nx">result</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attempt to guess strip prefixes for a given set of arguments.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">guessStripPrefixes: </span><span class="nf">(args) -&gt;</span>
    <span class="nv">result = </span><span class="p">[]</span>
    <span class="k">for</span> <span class="nx">arg</span> <span class="k">in</span> <span class="nx">args</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Most globs look something like dir/<em>*/</em>.ext, so strip up to the leading *</p></div></div><div class="code"><div class="wrapper">      <span class="nv">arg = </span><span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/\*.*$/</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span> <span class="nx">arg</span> <span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">pathSep</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For now, we try to avoid ambiguous situations by guessing the FIRST
directory given.  The assumption is that you don't want merged paths,
but probably did specify the most important source directory first.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="nx">_</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">uniq</span><span class="p">()[...</span><span class="mi">1</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>How many directories deep is a given path?</p></div></div><div class="code"><div class="wrapper">  <span class="nv">pathDepth: </span><span class="nf">(path) -&gt;</span>
    <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\/\\]/</span><span class="p">).</span><span class="nx">length</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Split source code into segments (comment + code pairs)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">splitSource: </span><span class="nf">(data, language, options={}) -&gt;</span>
    <span class="nv">lines = </span><span class="nx">data</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/\r?\n/</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Always strip shebangs - but don't shift it off the array to
avoid the perf hit of walking the array to update indices.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">]</span> <span class="o">is</span> <span class="s">&#39;#!&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Special case: If the language is comments-only, we can skip pygments</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="p">[</span><span class="k">new</span> <span class="nx">@Segment</span> <span class="p">[],</span> <span class="nx">lines</span><span class="p">]</span> <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">commentsOnly</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Special case: If the language is code-only, we can shorten the process</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="p">[</span><span class="k">new</span> <span class="nx">@Segment</span> <span class="nx">lines</span><span class="p">,</span> <span class="p">[]]</span> <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">codeOnly</span>

    <span class="nv">segments = </span><span class="p">[]</span>
    <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enforced whitespace after the comment token</p></div></div><div class="code"><div class="wrapper">    <span class="nv">whitespaceMatch = </span><span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">requireWhitespaceAfterToken</span> <span class="k">then</span> <span class="s">&#39;\\s&#39;</span> <span class="k">else</span> <span class="s">&#39;\\s?&#39;</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="o">?</span>
      <span class="nv">singleLines = </span><span class="nx">@regexpEscape</span><span class="p">(</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">).</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span>
      <span class="nv">aSingleLine = </span><span class="sr">///</span>
<span class="sr">        ^\s*                        # Start a line and skip all indention.</span>
<span class="sr">        (?:</span><span class="si">#{</span><span class="nx">singleLines</span><span class="si">}</span><span class="sr">)          # Match the single-line start but don&#39;t capture this group.</span>
<span class="sr">        (?:                         # Also don&#39;t capture this group …</span>
<span class="sr">          </span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">        # … possibly starting with a whitespace, but</span>
<span class="sr">          (.*)                      # … capture anything else in this …</span>
<span class="sr">        )?                          # … optional group …</span>
<span class="sr">        $                           # … up to the EOL.</span>
<span class="sr">      ///</span>


    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span><span class="o">?</span>
      <span class="nv">mlc = </span><span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span>

      <span class="k">unless</span> <span class="p">(</span><span class="nx">mlc</span><span class="p">.</span><span class="nx">length</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s">&#39;Multi-line block-comment definitions must be a list of 3-tuples&#39;</span><span class="p">)</span>

      <span class="nv">blockStarts = </span><span class="nx">_</span><span class="p">.</span><span class="nx">select</span> <span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="nv">blockLines  = </span><span class="nx">_</span><span class="p">.</span><span class="nx">select</span> <span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="nv">blockEnds   = </span><span class="nx">_</span><span class="p">.</span><span class="nx">select</span> <span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This flag indicates if the end-mark of block-comments (the <code>blockEnds</code>
list above) must correspond to the initial block-mark (the <code>blockStarts</code>
above).  If this flag is missing it defaults to <code>true</code>.  The main idea
is to embed sample block-comments with syntax A in another block-comment 
with syntax B. This useful in handlebar's mixed syntax or other language
combinations like html+php, which are supported by <code>pygmentize</code>.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">strictMultiLineEnd = </span><span class="nx">language</span><span class="p">.</span><span class="nx">strictMultiLineEnd</span> <span class="o">?</span> <span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This map is used to lookup corresponding line- and end-marks.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">blockComments = </span><span class="p">{}</span>
      <span class="k">for</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">blockStarts</span>
        <span class="nx">blockComments</span><span class="p">[</span><span class="nx">v</span><span class="p">]</span> <span class="o">=</span>
          <span class="nv">linemark: </span><span class="nx">blockLines</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
          <span class="nv">endmark : </span><span class="nx">blockEnds</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nv">blockStarts = </span><span class="nx">@regexpEscape</span><span class="p">(</span><span class="nx">blockStarts</span><span class="p">).</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span>
      <span class="nv">blockLines  = </span><span class="nx">@regexpEscape</span><span class="p">(</span><span class="nx">blockLines</span><span class="p">).</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span>
      <span class="nv">blockEnds   = </span><span class="nx">@regexpEscape</span><span class="p">(</span><span class="nx">blockEnds</span><span class="p">).</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No need to match for any particular real content in <code>aBlockStart</code>, as
either <code>aBlockLine</code>, <code>aBlockEnd</code> or the <code>inBlock</code> catch-all fallback
handles the real content, in the implementation below.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">aBlockStart = </span><span class="sr">///</span>
<span class="sr">        ^(\s*)                      # Start a line and capture indention, used to reverse indent catch-all fallback lines.</span>
<span class="sr">        (</span><span class="si">#{</span><span class="nx">blockStarts</span><span class="si">}</span><span class="sr">)            # Capture the start-mark, to check the if line- and end-marks correspond, …</span>
<span class="sr">        (</span><span class="si">#{</span><span class="nx">blockLines</span><span class="si">}</span><span class="sr">)?            # … possibly followed by a line, captured to check if its corresponding to the start,</span>
<span class="sr">        (?:</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">|$)    # … and finished by whitespace OR the EOL.</span>
<span class="sr">      ///</span>

      <span class="nv">aBlockLine = </span><span class="sr">///</span>
<span class="sr">        ^\s*                        # Start a line and skip all indention.</span>
<span class="sr">        (</span><span class="si">#{</span><span class="nx">blockLines</span><span class="si">}</span><span class="sr">)             # Capture the line-mark to check if it corresponds to the start-mark, …</span>
<span class="sr">        (</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">)        # … possibly followed by whitespace,</span>
<span class="sr">        (.*)$                       # … and collect all up to the line end.</span>
<span class="sr">      ///</span>

      <span class="nv">aBlockEnd = </span><span class="sr">///</span>
<span class="sr">        (</span><span class="si">#{</span><span class="nx">blockEnds</span><span class="si">}</span><span class="sr">)              # Capture the end-mark to check if it corresponds to the line start,</span>
<span class="sr">        (.*)?$                      # … and collect all up to the line end.</span>
<span class="sr">      ///</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A special case used to capture empty block-comment lines, like the one
below this line …</p>

<p>… and above this line.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">aEmptyLine = </span><span class="sr">///^\s*(?:</span><span class="si">#{</span><span class="nx">blockLines</span><span class="si">}</span><span class="sr">)$///</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">ignorePrefix</span><span class="o">?</span>
      <span class="p">{</span><span class="nx">ignorePrefix</span><span class="p">}</span> <span class="o">=</span> <span class="nx">language</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">foldPrefix</span><span class="o">?</span>
      <span class="p">{</span><span class="nx">foldPrefix</span><span class="p">}</span> <span class="o">=</span> <span class="nx">language</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">ignorePrefix</span><span class="o">?</span> <span class="o">or</span> <span class="nx">foldPrefix</span><span class="o">?</span><span class="p">)</span> <span class="o">and</span> <span class="p">(</span><span class="nx">singleLines</span><span class="o">?</span> <span class="o">or</span> <span class="nx">blockStarts</span><span class="o">?</span><span class="p">)</span>
      <span class="nv">stripMarks = </span><span class="p">[]</span>
      <span class="nx">stripMarks</span><span class="p">.</span><span class="nx">push</span> <span class="nx">ignorePrefix</span> <span class="k">if</span> <span class="nx">ignorePrefix</span><span class="o">?</span>
      <span class="nx">stripMarks</span><span class="p">.</span><span class="nx">push</span> <span class="nx">foldPrefix</span> <span class="k">if</span> <span class="nx">foldPrefix</span><span class="o">?</span>
      <span class="nv">stripMarks = </span><span class="nx">@regexpEscape</span><span class="p">(</span><span class="nx">stripMarks</span><span class="p">).</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A dirty lap-dance performed here …</p></div></div><div class="code"><div class="wrapper">      <span class="nv">singleStrip = </span><span class="sr">///</span>
<span class="sr">        (                           # Capture this group:</span>
<span class="sr">          (?:</span><span class="si">#{</span><span class="nx">singleLines</span><span class="si">}</span><span class="sr">)        #   The comment marker(s) to keep …</span>
<span class="sr">          </span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">        #   … plus whitespace</span>
<span class="sr">        )</span>
<span class="sr">        (?:</span><span class="si">#{</span><span class="nx">stripMarks</span><span class="si">}</span><span class="sr">)           # The marker(s) to strip from result</span>
<span class="sr">      ///</span> <span class="k">if</span> <span class="nx">singleLines</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>… and the corresponding gang-bang here. 8-)</p></div></div><div class="code"><div class="wrapper">      <span class="nv">blockStrip = </span><span class="sr">///</span>
<span class="sr">        (                           # Capture this group:</span>
<span class="sr">          (?:</span><span class="si">#{</span><span class="nx">blockStarts</span><span class="si">}</span><span class="sr">)        #   The comment marker(s) to keep …</span>
<span class="sr">          (?:</span><span class="si">#{</span><span class="nx">blockLines</span><span class="si">}</span><span class="sr">)?        #   … optionally plus one more mark</span>
<span class="sr">          </span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">        #   … plus whitespace</span>
<span class="sr">        )</span>
<span class="sr">        (?:</span><span class="si">#{</span><span class="nx">stripMarks</span><span class="si">}</span><span class="sr">)           # The marker(s) to strip from result</span>
<span class="sr">      ///</span> <span class="k">if</span> <span class="nx">blockStarts</span><span class="o">?</span>

    <span class="nv">inBlock   = </span><span class="kc">false</span>
    <span class="nv">inFolded  = </span><span class="kc">false</span>
    <span class="nv">inIgnored = </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Variables used in temporary assignments have been collected here for
documentation purposes only. </p></div></div><div class="code"><div class="wrapper">    <span class="nv">blockline = </span><span class="kc">null</span>
    <span class="nv">blockmark = </span><span class="kc">null</span>
    <span class="nv">linemark  = </span><span class="kc">null</span>
    <span class="nv">space     = </span><span class="kc">null</span>
    <span class="nv">endmark   = </span><span class="kc">null</span>
    <span class="nv">indention = </span><span class="kc">null</span>
    <span class="nv">comment   = </span><span class="kc">null</span>
    <span class="nv">code      = </span><span class="kc">null</span>

    <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">lines</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match that line to the language's block-comment syntax, if it exists</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="nx">aBlockStart</span><span class="o">?</span> <span class="o">and</span> <span class="o">not</span> <span class="nx">inBlock</span> <span class="o">and</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">aBlockStart</span><span class="p">)</span><span class="o">?</span>
        <span class="nv">inBlock = </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reusing <code>match</code> as a placeholder.</p></div></div><div class="code"><div class="wrapper">        <span class="p">[</span><span class="nx">match</span><span class="p">,</span> <span class="nx">indention</span><span class="p">,</span> <span class="nx">blockmark</span><span class="p">,</span> <span class="nx">linemark</span><span class="p">]</span> <span class="o">=</span> <span class="nx">match</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Strip the block-comments start, preserving any inline stuff.
We don't touch the <code>line</code> itself, as we still need it.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">blockline = </span><span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">aBlockStart</span><span class="p">,</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we found a <code>linemark</code>, prepend it (back) to the <code>blockline</code>, if it
does not correspond to the initial <code>blockmark</code>.</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="nx">linemark</span><span class="o">?</span> <span class="o">and</span> <span class="nx">blockComments</span><span class="p">[</span><span class="nx">blockmark</span><span class="p">].</span><span class="nx">linemark</span> <span class="o">isnt</span> <span class="nx">linemark</span>
          <span class="nv">blockline = </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">linemark</span><span class="si">}#{</span><span class="nx">blockline</span><span class="si">}</span><span class="s">&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if this block-comment is collapsible.</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="nx">foldPrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">blockline</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">foldPrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We always start a new segment if the current one is not empty or 
already folded.</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span> <span class="nx">inFolded</span> <span class="o">or</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
            <span class="nv">currSegment   = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="code folded"><div class="wrapper marker"><span class="c1">          ###  collapsing block-comments:</span></div><div class="wrapper">          <span class="cm">###  collapsing block-comments:</span>
<span class="cm">          # In block-comments only `aBlockStart` may initiate the collapsing.</span>
<span class="cm">          # This comment utilizes this syntax, by starting the comment with `^`.</span>
<span class="cm">          ###</span>
          <span class="nv">inFolded  = </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “^” character from our original line, for later use.</p></div></div><div class="code"><div class="wrapper">          <span class="nv">line = </span><span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">blockStrip</span><span class="p">,</span> <span class="s">&#39;$1&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Also strip it from our <code>blockline</code>.</p></div></div><div class="code"><div class="wrapper">          <span class="nv">blockline = </span><span class="nx">blockline</span><span class="p">[</span><span class="nx">foldPrefix</span><span class="p">.</span><span class="nx">length</span><span class="p">...]</span> </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if this block-comment stays embedded in the code.</p></div></div><div class="code"><div class="wrapper">        <span class="k">else</span> <span class="k">if</span> <span class="nx">ignorePrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">blockline</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">ignorePrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span>
          <span class="cm">###  embedded block-comments:</span>
<span class="cm">          # In block-comments only `aBlockStart` may initiate the embedding.</span>
<span class="cm">          # This comment utilizes this syntax, by starting the comment with `}`.</span>
<span class="cm">          ###</span>
          <span class="nv">inIgnored = </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “}” character from our original line, for later use.</p></div></div><div class="code"><div class="wrapper">          <span class="nv">line = </span><span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">blockStrip</span><span class="p">,</span> <span class="s">&#39;$1&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Also strip it from our <code>blockline</code>.</p></div></div><div class="code"><div class="wrapper">          <span class="nv">blockline = </span><span class="nx">blockline</span><span class="p">[</span><span class="nx">ignorePrefix</span><span class="p">.</span><span class="nx">length</span><span class="p">...]</span> </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Block-comments are an important tool to structure code into larger
segments, therefore we always start a new segment if the current one
is not empty.</p></div></div><div class="code"><div class="wrapper">        <span class="k">else</span> <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
          <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
          <span class="nv">currSegment   = </span><span class="k">new</span> <span class="nx">@Segment</span>
          <span class="nv">inFolded      = </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This flag is triggered above.</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="nx">inBlock</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Catch all lines, unless there is a <code>blockline</code> from above.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">blockline = </span><span class="nx">line</span> <span class="k">unless</span> <span class="nx">blockline</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match a block-comment's end, even when <code>inFolded or inIgnored</code> flags
are true …</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">blockline</span><span class="p">.</span><span class="nx">match</span> <span class="nx">aBlockEnd</span><span class="p">)</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reusing <code>match</code> as a placeholder.</p></div></div><div class="code"><div class="wrapper">          <span class="p">[</span><span class="nx">match</span><span class="p">,</span> <span class="nx">endmark</span><span class="p">,</span> <span class="nx">code</span><span class="p">]</span> <span class="o">=</span> <span class="nx">match</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>endmark</code> must correspond to the <code>blockmark</code>'s.</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span> <span class="o">not</span> <span class="nx">strictMultiLineEnd</span> <span class="o">or</span> <span class="nx">blockComments</span><span class="p">[</span><span class="nx">blockmark</span><span class="p">].</span><span class="nx">endmark</span> <span class="o">is</span> <span class="nx">endmark</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure to leave the block-comment, especially single-lines like this one.</p></div></div><div class="code"><div class="wrapper">            <span class="nv">inBlock = </span><span class="kc">false</span>

            <span class="nv">blockline = </span><span class="nx">blockline</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">aBlockEnd</span><span class="p">,</span> <span class="s">&#39;&#39;</span> <span class="k">unless</span> <span class="p">(</span><span class="nx">inFolded</span> <span class="o">or</span> <span class="nx">inIgnored</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match a block-comment's line, when <code>inFolded or inIgnored</code> are false.</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span> <span class="o">not</span> <span class="p">(</span><span class="nx">inFolded</span> <span class="o">or</span> <span class="nx">inIgnored</span><span class="p">)</span> <span class="o">and</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">blockline</span><span class="p">.</span><span class="nx">match</span> <span class="nx">aBlockLine</span><span class="p">)</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reusing <code>match</code> as a placeholder.</p></div></div><div class="code"><div class="wrapper">          <span class="p">[</span><span class="nx">match</span><span class="p">,</span> <span class="nx">linemark</span><span class="p">,</span> <span class="nx">space</span><span class="p">,</span> <span class="nx">comment</span><span class="p">]</span> <span class="o">=</span> <span class="nx">match</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we found a <code>linemark</code>, prepend it (back) to the <code>comment</code>,
if it does not correspond to the initial <code>blockmark</code>.</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span> <span class="nx">linemark</span><span class="o">?</span> <span class="o">and</span> <span class="nx">blockComments</span><span class="p">[</span><span class="nx">blockmark</span><span class="p">].</span><span class="nx">linemark</span> <span class="o">isnt</span> <span class="nx">linemark</span>
            <span class="nv">comment = </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">linemark</span><span class="si">}#{</span><span class="nx">space</span> <span class="o">?</span> <span class="s">&#39;&#39;</span><span class="si">}#{</span><span class="nx">comment</span><span class="si">}</span><span class="s">&quot;</span>

          <span class="nv">blockline = </span><span class="nx">comment</span>

        <span class="k">if</span> <span class="nx">inIgnored</span>
          <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure that the next cycle starts fresh, 
if we are going to leave the block.</p></div></div><div class="code"><div class="wrapper">          <span class="nv">inIgnored = </span><span class="kc">false</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">inBlock</span>

        <span class="k">else</span>

          <span class="k">if</span> <span class="nx">inFolded</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the foldMarker is empty assign <code>blockline</code> to <code>foldMarker</code> …</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">foldMarker</span> <span class="o">is</span> <span class="s">&#39;&#39;</span>
              <span class="nv">currSegment.foldMarker = </span><span class="nx">line</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>… and collect the <code>blockline</code> as code.</p></div></div><div class="code"><div class="wrapper">            <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

          <span class="k">else</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The previous cycle contained code, so lets start a new segment.</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
              <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A special case as described in the initialization of <code>aEmptyLine</code>.</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">aEmptyLine</span><span class="p">.</span><span class="nx">test</span> <span class="nx">line</span>
              <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="s">&quot;&quot;</span>

            <span class="k">else</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Collect all but empty start- and end-block-comment lines, hence
single-line block-comments simultaneous matching <code>aBlockStart</code>
and <code>aBlockEnd</code> have a false <code>inBlock</code> flag at this point, are
included.</p></div></div><div class="code"><div class="wrapper">              <span class="k">if</span> <span class="o">not</span> <span class="sr">/^\s*$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">blockline</span><span class="p">)</span> <span class="o">or</span> <span class="p">(</span><span class="nx">inBlock</span> <span class="o">and</span> <span class="o">not</span> <span class="nx">aBlockStart</span><span class="p">.</span><span class="nx">test</span> <span class="nx">line</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Strip leading <code>indention</code> from block-comment like the one above
to align their content with the initial blockmark.</p></div></div><div class="code"><div class="wrapper">                <span class="k">if</span> <span class="nx">indention</span><span class="o">?</span> <span class="o">and</span> <span class="nx">indention</span> <span class="o">isnt</span> <span class="s">&#39;&#39;</span> <span class="o">and</span> <span class="o">not</span> <span class="nx">aBlockLine</span><span class="p">.</span><span class="nx">test</span> <span class="nx">line</span>
                  <span class="nv">blockline = </span><span class="nx">blockline</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">///^</span><span class="si">#{</span><span class="nx">indention</span><span class="si">}</span><span class="sr">///</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

                <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">blockline</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>code</code> may occure immediatly after a block-comment end.</p></div></div><div class="code"><div class="wrapper">              <span class="k">if</span> <span class="nx">code</span><span class="o">?</span>
                <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">code</span> <span class="k">unless</span> <span class="nx">inBlock</span> <span class="c1"># fool-proof ?</span>
                <span class="nv">code = </span><span class="kc">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make sure the next cycle starts fresh.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">blockline = </span><span class="kc">null</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match that line to the language's single line comment syntax.
However, we treat all comments beginning with } as inline code commentary
and comments starting with ^ cause that comment and the following code
block to start folded.</p></div></div><div class="code"><div class="wrapper">      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">aSingleLine</span><span class="p">)</span><span class="o">?</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Uses <code>match</code> as a placeholder.</p></div></div><div class="code"><div class="wrapper">        <span class="p">[</span><span class="nx">match</span><span class="p">,</span> <span class="nx">comment</span><span class="p">]</span> <span class="o">=</span> <span class="nx">match</span>

        <span class="k">if</span> <span class="nx">comment</span><span class="o">?</span> <span class="o">and</span> <span class="nx">comment</span> <span class="o">isnt</span> <span class="s">&#39;&#39;</span>

          <span class="c1">#  For example, this comment should be treated as part of our code.</span>
          <span class="c1">#  Achieved by prefixing the comment&#39;s content with “}”</span>
          <span class="k">if</span> <span class="nx">ignorePrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">comment</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">ignorePrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span>

            <span class="c1">#  Hint: never start a new segment here, these comments are code !</span>
            <span class="c1">#  If we would do so the segments look visually not so appealing in</span>
            <span class="c1">#  the narrowed single-column-view, and we can not embed a series</span>
            <span class="c1">#  of comments like these here.</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “}” character from our documentation</p></div></div><div class="code"><div class="wrapper">            <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">singleStrip</span><span class="p">,</span> <span class="s">&#39;$1&#39;</span>

          <span class="k">else</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The previous cycle contained code, so lets start a new segment
and stop any folding.</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
              <span class="nv">currSegment   = </span><span class="k">new</span> <span class="nx">@Segment</span>
              <span class="nv">inFolded      = </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It's always a good idea to put a comment before folded content
like this one here, because folded comments always have their
own code-segment in their current implementation (see above).
Without a leading comment, the folded code's segment would just
follow the above's code segment, which looks visually not so
appealing in the narrowed single-column-view.  </p>

<p>TODO: <em>Alternative (a)</em>: Improve folded comments to not start a new segment, like embedded comments from above. <em>(preferred solution)</em> <br />
TODO: <em>Alternative (b)</em>: Improve folded comments visual appearance in single-column view. <em>(easy solution)</em>  </p></div></div><div class="code folded"><div class="wrapper marker"><span class="c1">            #  … if we start this comment with “^” instead of “}” it and all</span></div><div class="wrapper">            <span class="c1">#  … if we start this comment with “^” instead of “}” it and all</span>
            <span class="c1">#  code up to the next segment&#39;s first comment starts folded</span>
            <span class="k">if</span> <span class="nx">foldPrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">comment</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">foldPrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span>

              <span class="c1">#  … so folding stops below, as this is a new segment !</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “^” character from our documentation</p></div></div><div class="code"><div class="wrapper">              <span class="nv">currSegment.foldMarker = </span><span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">singleStrip</span><span class="p">,</span> <span class="s">&#39;$1&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>And collect it as code.</p></div></div><div class="code"><div class="wrapper">              <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">foldMarker</span>
            <span class="k">else</span>
              <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">comment</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We surely (should) have raw code at this point.</p></div></div><div class="code"><div class="wrapper">      <span class="k">else</span>
        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

    <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>

    <span class="nx">segments</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Just a convenient prototype for building segments</p></div></div><div class="code"><div class="wrapper">  <span class="nv">Segment: </span><span class="k">class</span> <span class="nx">Segment</span>
    <span class="nv">constructor: </span><span class="nf">(code=[], comments=[], foldMarker=&#39;&#39;) -&gt;</span>
      <span class="vi">@code     = </span><span class="nx">code</span>
      <span class="vi">@comments = </span><span class="nx">comments</span>
      <span class="vi">@foldMarker = </span><span class="nx">foldMarker</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annotate an array of segments by running their code through <a href="http://pygments.org/">Pygments</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">highlightCode: </span><span class="nf">(segments, language, callback) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don't bother spawning pygments if we have nothing to highlight</p></div></div><div class="code"><div class="wrapper">    <span class="nv">numCodeLines = </span><span class="nx">segments</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span> <span class="nf">(c,s) -&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="p">),</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">numCodeLines</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="nx">segment</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="s">&#39;&#39;</span>

      <span class="k">return</span> <span class="nx">callback</span><span class="p">()</span>

    <span class="nv">errListener = </span><span class="nf">(error) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This appears to only occur when pygmentize is missing:</p></div></div><div class="code"><div class="wrapper">      <span class="nx">Logger</span><span class="p">.</span><span class="nx">error</span> <span class="s">&quot;Unable to find &#39;pygmentize&#39; on your PATH.  Please install pygments.&quot;</span>
      <span class="nx">Logger</span><span class="p">.</span><span class="nx">info</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lack of pygments is a one time setup task, we don't feel bad about killing the process
off until the user does so.  It's a hard requirement.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span> <span class="mi">1</span>

    <span class="nv">pygmentize = </span><span class="nx">childProcess</span><span class="p">.</span><span class="nx">spawn</span> <span class="s">&#39;pygmentize&#39;</span><span class="p">,</span> <span class="p">[</span>
      <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="nx">language</span><span class="p">.</span><span class="nx">pygmentsLexer</span>
      <span class="s">&#39;-f&#39;</span><span class="p">,</span> <span class="s">&#39;html&#39;</span>
      <span class="s">&#39;-O&#39;</span><span class="p">,</span> <span class="s">&#39;encoding=utf-8,tabsize=2&#39;</span>
    <span class="p">]</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stderr</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data)  -&gt;</span> <span class="nx">callback</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="nx">errListener</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">on</span> <span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="nx">errListener</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We'll just split the output at the end.  pygmentize doesn't stream its output, and a given
source file is small enough that it shouldn't matter.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data) =&gt;</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>v0.8 changed exit/close event semantics.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">match = </span><span class="nx">process</span><span class="p">.</span><span class="nx">version</span><span class="p">.</span><span class="nx">match</span> <span class="sr">/v(\d+\.\d+)/</span>
    <span class="nv">closeEvent = </span><span class="k">if</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.8</span> <span class="k">then</span> <span class="s">&#39;exit&#39;</span> <span class="k">else</span> <span class="s">&#39;close&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can't include either of the following words ANYWHERE directly adjacent to each other
Otherwise, our regex (~10 lines below) will split on them, and the number of code blocks
and comment blocks will not be equal.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">seg = </span><span class="s">&#39;SEGMENT&#39;</span>
    <span class="nv">div = </span><span class="s">&#39;DIVIDER&#39;</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">addListener</span> <span class="nx">closeEvent</span><span class="p">,</span> <span class="nf">(args...) =&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>pygments spits it out wrapped in <code>&lt;div class="highlight"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</code>.  We want to
manage the styling ourselves, so remove that.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">result = </span><span class="nx">result</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;/pre&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extract our segments from the pygmentized source.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">highlighted = </span><span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">result</span><span class="si">}</span><span class="s">\n&quot;</span><span class="p">.</span><span class="nx">split</span> <span class="sr">///.*&lt;span.*</span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="sr">\s</span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="sr">.*&lt;\/span&gt;.*///</span>

      <span class="k">if</span> <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

        <span class="nv">error = </span><span class="k">new</span> <span class="nb">Error</span> <span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">format</span> <span class="s">&#39;pygmentize rendered %d of %d segments; expected to be equal&#39;</span><span class="p">,</span>
          <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>

        <span class="nv">error.pygmentsOutput   = </span><span class="nx">result</span>
        <span class="nv">error.failedHighlights = </span><span class="nx">highlighted</span>
        <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach highlighted source to the highlightedCode property of a Segment.</p></div></div><div class="code"><div class="wrapper">      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="nx">highlighted</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Rather than spawning pygments for each segment, we stream it all in, separated by 'magic'
comments so that we can split the highlighted source back into segments.
To further complicate things, pygments doesn't let us cheat with indentation-aware languages:
We have to match the indentation of the line following the divider comment.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">mergedCode = </span><span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
      <span class="nv">segmentCode = </span><span class="nx">segment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>

      <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Double negative: match characters that are spaces but not newlines</p></div></div><div class="code"><div class="wrapper">        <span class="nv">indentation = </span><span class="nx">segmentCode</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^[^\S\n]+/</span><span class="p">)</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="o">?</span>
          <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">indentation</span><span class="si">}#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="s">\n&quot;</span>
        <span class="k">else</span>
          <span class="nv">mlc = </span><span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span>
          <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">indentation</span><span class="si">}#{</span><span class="nx">mlc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">mlc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s">\n&quot;</span>

      <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="nx">segmentCode</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">write</span> <span class="nx">mergedCode</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>

  <span class="nv">parseDocTags: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">TAG_REGEX = </span><span class="sr">/(?:^|\s)@(\w+)(?:\s+(.*))?/</span>
    <span class="nv">TAG_VALUE_REGEX = </span><span class="sr">/^(?:&quot;(.*)&quot;|&#39;(.*)&#39;|\{(.*)\}|(.*))$/</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span> <span class="k">when</span> <span class="nx">TAG_REGEX</span><span class="p">.</span><span class="nx">test</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;\n&#39;</span><span class="p">)</span>
        <span class="nv">tags = </span><span class="p">[]</span>
        <span class="nv">currTag = </span><span class="p">{</span>
          <span class="nv">name: </span><span class="s">&#39;description&#39;</span>
          <span class="nv">value: </span><span class="s">&#39;&#39;</span>
        <span class="p">}</span>
        <span class="nx">tags</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currTag</span>
        <span class="nv">tagSections = </span><span class="p">{}</span>

        <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span> <span class="k">when</span> <span class="nx">line</span><span class="o">?</span>
          <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">TAG_REGEX</span><span class="p">)</span><span class="o">?</span>
            <span class="nv">currTag = </span><span class="p">{</span>
              <span class="nv">name: </span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
              <span class="nv">value: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="s">&#39;&#39;</span>
            <span class="p">}</span>
            <span class="nx">tags</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currTag</span>
          <span class="k">else</span>
            <span class="nx">currTag</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">line</span><span class="si">}</span><span class="s">&quot;</span>

        <span class="k">for</span> <span class="nx">tag</span> <span class="k">in</span> <span class="nx">tags</span>
          <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/^\n|\n$/g</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

          <span class="nv">tagDefinition = </span><span class="nx">DOC_TAGS</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span>

          <span class="k">unless</span> <span class="nx">tagDefinition</span><span class="o">?</span>
            <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
              <span class="nv">tagDefinition = </span><span class="s">&#39;defaultNoValue&#39;</span>
            <span class="k">else</span>
              <span class="nv">tagDefinition = </span><span class="s">&#39;defaultHasValue&#39;</span>

          <span class="k">if</span> <span class="s">&#39;string&#39;</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">tagDefinition</span>
            <span class="nv">tagDefinition = </span><span class="nx">DOC_TAGS</span><span class="p">[</span><span class="nx">tagDefinition</span><span class="p">]</span>

          <span class="nv">tag.definition = </span><span class="nx">tagDefinition</span>
          <span class="nv">tag.section = </span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">section</span>

          <span class="k">if</span> <span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">valuePrefix</span><span class="o">?</span>
            <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">///</span><span class="si">#{</span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">valuePrefix</span><span class="o">?</span><span class="si">}</span><span class="sr">\s+///</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

          <span class="k">if</span> <span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">parseValue</span><span class="o">?</span>
            <span class="nv">tag.value = </span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">parseValue</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
          <span class="k">else</span> <span class="k">if</span> <span class="o">not</span> <span class="sr">/\n/</span><span class="p">.</span><span class="nx">test</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
            <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">TAG_VALUE_REGEX</span><span class="p">)[</span><span class="mi">1</span><span class="p">..].</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

          <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">unless</span> <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">]</span><span class="o">?</span>
          <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">].</span><span class="nx">push</span> <span class="nx">tag</span>

        <span class="nv">segment.tags = </span><span class="nx">tags</span>
        <span class="nv">segment.tagSections = </span><span class="nx">tagSections</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span>

  <span class="nv">markdownDocTags: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span> <span class="k">when</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">tags</span><span class="o">?</span>

        <span class="k">for</span> <span class="nx">tag</span> <span class="k">in</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">tags</span>
          <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="o">?</span>
            <span class="k">if</span> <span class="s">&#39;string&#39;</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/\{value\}/g</span><span class="p">,</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
            <span class="k">else</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="p">(</span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
          <span class="k">else</span>
            <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nv">tag.markdown = </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="s">&quot;</span>
            <span class="k">else</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annotate an array of segments by running their comments through
<a href="https://github.com/coreyti/showdown">showdown</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">markdownComments: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">converter = </span><span class="k">new</span> <span class="nx">showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">(</span><span class="nv">extensions: </span><span class="nx">project</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">showdown</span><span class="p">)</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">markdown = </span><span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>
        <span class="nv">headers  = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>showdown generates header ids by lowercasing &amp; dropping non-word characters.  We'd like
something a bit more readable.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">markdown = </span><span class="nx">@gsub</span> <span class="nx">markdown</span><span class="p">,</span> <span class="sr">/&lt;h(\d) id=&quot;[^&quot;]+&quot;&gt;([^&lt;]+)&lt;\/h\d&gt;/g</span><span class="p">,</span> <span class="nf">(match) =&gt;</span>
          <span class="nv">header =</span>
            <span class="nv">level: </span><span class="nb">parseInt</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nv">title: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="nv">slug: </span> <span class="nx">@slugifyTitle</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

          <span class="nv">header.isFileHeader = </span><span class="kc">true</span> <span class="k">if</span> <span class="nx">header</span><span class="p">.</span><span class="nx">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">segmentIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span>

          <span class="nx">headers</span><span class="p">.</span><span class="nx">push</span> <span class="nx">header</span>

          <span class="s">&quot;&lt;h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s"> id=\&quot;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">slug</span><span class="si">}</span><span class="s">\&quot;&gt;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="s">&lt;/h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s">&gt;&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We attach the rendered markdown to the comment</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.markdownedComments = </span><span class="nx">markdown</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>As well as the extracted headers to aid in outline building.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.headers = </span><span class="nx">headers</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sometimes you just don't want any of them hanging around.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">trimBlankLines: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[\r\n]+/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\r\n]+$/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a title, convert it into a URL-friendly slug.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">slugifyTitle: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\s\-\_]+/</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span> <span class="nf">(s) -&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w]/g</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">).</span><span class="nx">join</span> <span class="s">&#39;-&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>replacer is a function that is given the match object, and returns the string to replace with.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">gsub: </span><span class="nf">(string, matcher, replacer) -&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="s">&#39;You must pass a global RegExp to gsub!&#39;</span> <span class="k">unless</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">global</span><span class="o">?</span>

    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nv">matcher.lastIndex = </span><span class="mi">0</span>
    <span class="nv">furthestIndex = </span><span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">exec</span> <span class="nx">string</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...</span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">replacer</span> <span class="nx">match</span>

      <span class="nv">furthestIndex = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">lastIndex</span>

    <span class="nx">result</span> <span class="o">+</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...]</span></div></div></div></div></body></html>