<!DOCTYPE html><html lang="en"><head><title>utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="utils"><meta name="groc-project-path" content="lib/utils.coffee"><meta name="groc-github-url" content="https://github.com/sjorek/groc"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/sjorek/groc/blob/master/lib/utils.coffee">lib/utils.coffee</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Miscellaneous code fragments reside here.
TODO: These should be migrated into <code>lib/utils</code>.</p></div></div><div class="code"><div class="wrapper"><span class="nv">childProcess = </span><span class="nx">require</span> <span class="s">&#39;child_process&#39;</span>
<span class="nv">path         = </span><span class="nx">require</span> <span class="s">&#39;path&#39;</span>

<span class="nv">_        = </span><span class="nx">require</span> <span class="s">&#39;underscore&#39;</span>
<span class="nv">showdown = </span><span class="nx">require</span> <span class="s">&#39;showdown&#39;</span>

<span class="nv">CompatibilityHelpers = </span><span class="nx">require</span> <span class="s">&#39;./utils/compatibility_helpers&#39;</span>
<span class="nv">LANGUAGES            = </span><span class="kc">null</span>
<span class="nv">DOC_TAGS             = </span><span class="kc">null</span>
<span class="nv">Logger               = </span><span class="nx">require</span> <span class="s">&#39;./utils/logger&#39;</span>
<span class="nv">DOCTAGHelpers        = </span><span class="nx">require</span> <span class="s">&#39;./utils/doctag_helpers&#39;</span>

<span class="nv">module.exports = Utils =</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Escape regular expression characters in a string
Code from http://zetafleet.com/ via http://simonwillison.net/2006/Jan/20/escape/</p></div></div><div class="code"><div class="wrapper">  <span class="nv">regexpEscape: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[-[\]{}()*+?.,\\^$|#\s]/g</span><span class="p">,</span> <span class="s">&#39;\\$&amp;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detect and return the language that a given file is written in.
The language is also annotated with a name property, matching the laguages key in LANGUAGES.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getLanguage: </span><span class="nf">(filePath, languageDefinitions = &#39;./languages&#39;) -&gt;</span>
    <span class="k">unless</span> <span class="nx">@_languageDetectionCache</span><span class="o">?</span>
      <span class="vi">@_languageDetectionCache = </span><span class="p">[]</span>

      <span class="nv">LANGUAGES = </span><span class="nx">require</span><span class="p">(</span><span class="nx">languageDefinitions</span><span class="p">)</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">LANGUAGES</span><span class="o">?</span>

      <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">language</span> <span class="k">of</span> <span class="nx">LANGUAGES</span>
        <span class="nv">language.name = </span><span class="nx">name</span>

        <span class="k">for</span> <span class="nx">matcher</span> <span class="k">in</span> <span class="nx">language</span><span class="p">.</span><span class="nx">nameMatchers</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the matcher is a string, we assume that it's a file extension.  Stick it in a regex:</p></div></div><div class="code"><div class="wrapper">          <span class="nv">matcher = </span><span class="sr">///</span><span class="si">#{</span><span class="nx">@regexpEscape</span> <span class="nx">matcher</span><span class="si">}</span><span class="sr">$///</span> <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isString</span> <span class="nx">matcher</span>

          <span class="nx">@_languageDetectionCache</span><span class="p">.</span><span class="nx">push</span> <span class="p">[</span><span class="nx">matcher</span><span class="p">,</span> <span class="nx">language</span><span class="p">]</span>

    <span class="nv">baseName = </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span> <span class="nx">filePath</span>

    <span class="k">for</span> <span class="nx">pair</span> <span class="k">in</span> <span class="nx">@_languageDetectionCache</span>
      <span class="k">return</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nx">baseName</span><span class="p">.</span><span class="nx">match</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map a list of file paths to relative target paths by stripping prefixes off of them.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">mapFiles: </span><span class="nf">(resolveRoot, files, stripPrefixes) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure that we're dealing with absolute paths across the board</p></div></div><div class="code"><div class="wrapper">    <span class="nv">files = </span><span class="nx">files</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(f) -&gt;</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span> <span class="nx">resolveRoot</span><span class="p">,</span> <span class="nx">f</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>And that the strip prefixes all end with a /, to avoid a target path being absolute.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">stripPrefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(p) -&gt;</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span> <span class="nx">resolveRoot</span><span class="p">,</span> <span class="nx">p</span><span class="si">}#{</span><span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">pathSep</span><span class="si">}</span><span class="s">&quot;</span> <span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prefixes are stripped in order of most specific to least (# of directories deep)</p></div></div><div class="code"><div class="wrapper">    <span class="nv">prefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">sort</span> <span class="nf">(a,b) =&gt;</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="nv">result = </span><span class="p">{}</span>

    <span class="k">for</span> <span class="nx">absPath</span> <span class="k">in</span> <span class="nx">files</span>
      <span class="nv">file = </span><span class="nx">absPath</span>

      <span class="k">for</span> <span class="nx">stripPath</span> <span class="k">in</span> <span class="nx">stripPrefixes</span>
        <span class="nv">file = </span><span class="nx">file</span><span class="p">[</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">..]</span> <span class="k">if</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">==</span> <span class="nx">stripPath</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We also strip the extension under the assumption that the consumer of this path map is going
to substitute in their own.  Plus, if they care about the extension, they can get it from
the keys of the map.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">result</span><span class="p">[</span><span class="nx">absPath</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="k">then</span> <span class="nx">file</span> <span class="k">else</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="o">-</span><span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">).</span><span class="nx">length</span><span class="p">]</span>

    <span class="nx">result</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attempt to guess strip prefixes for a given set of arguments.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">guessStripPrefixes: </span><span class="nf">(args) -&gt;</span>
    <span class="nv">result = </span><span class="p">[]</span>
    <span class="k">for</span> <span class="nx">arg</span> <span class="k">in</span> <span class="nx">args</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Most globs look something like dir/<em>*/</em>.ext, so strip up to the leading *</p></div></div><div class="code"><div class="wrapper">      <span class="nv">arg = </span><span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/\*.*$/</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span> <span class="nx">arg</span> <span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">pathSep</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For now, we try to avoid ambiguous situations by guessing the FIRST directory given.  The
assumption is that you don't want merged paths, but probably did specify the most important
source directory first.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="nx">_</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">uniq</span><span class="p">()[...</span><span class="mi">1</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>How many directories deep is a given path?</p></div></div><div class="code"><div class="wrapper">  <span class="nv">pathDepth: </span><span class="nf">(path) -&gt;</span>
    <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\/\\]/</span><span class="p">).</span><span class="nx">length</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Split source code into segments (comment + code pairs)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">splitSource: </span><span class="nf">(data, language, options={}) -&gt;</span>
    <span class="nv">lines = </span><span class="nx">data</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/\r?\n/</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Always strip shebangs - but don't shift it off the array to avoid the perf hit of walking the
array to update indices.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;#!&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Special case: If the language is comments-only, we can skip pygments</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="p">[</span><span class="k">new</span> <span class="nx">@Segment</span> <span class="p">[],</span> <span class="nx">lines</span><span class="p">]</span> <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">commentsOnly</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this flag is used to signal literate source code</p></div></div><div class="code"><div class="wrapper">    <span class="nv">segments = </span><span class="p">[]</span>
    <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enforced whitespace after the comment token</p></div></div><div class="code"><div class="wrapper">    <span class="nv">whitespaceMatch = </span><span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">requireWhitespaceAfterToken</span> <span class="k">then</span> <span class="s">&#39;\\s&#39;</span> <span class="k">else</span> <span class="s">&#39;\\s?&#39;</span>

    <span class="nv">isLiterateCode = </span><span class="kc">false</span>
    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">literateCodeLines</span><span class="o">?</span>
      <span class="nv">isLiterateCode = </span><span class="kc">true</span>
      <span class="nv">codeLineMatcher = </span><span class="sr">///^(</span><span class="si">#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">literateCodeLines</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)(?:(.*))?$///</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="o">?</span>
      <span class="nv">singleLineMatcher = </span><span class="sr">///^\s*(</span><span class="si">#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">)(?:</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">(.*))?$///</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span><span class="o">?</span>
      <span class="nv">mlc = </span><span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span>

      <span class="nv">blockStarts = </span><span class="nx">_</span><span class="p">.</span><span class="nx">invoke</span> <span class="nx">_</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&#39;replace&#39;</span><span class="p">,</span> <span class="sr">/([\\\*\{\}])/g</span><span class="p">,</span> <span class="s">&#39;\\\$1&#39;</span>
      <span class="nv">blockLines  = </span><span class="nx">_</span><span class="p">.</span><span class="nx">invoke</span> <span class="nx">_</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&#39;replace&#39;</span><span class="p">,</span> <span class="sr">/([\\\*\{\}])/g</span><span class="p">,</span> <span class="s">&#39;\\\$1&#39;</span>
      <span class="nv">blockEnds   = </span><span class="nx">_</span><span class="p">.</span><span class="nx">invoke</span> <span class="nx">_</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">mlc</span><span class="p">,</span> <span class="nf">(v, i) -&gt;</span> <span class="nx">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="s">&#39;replace&#39;</span><span class="p">,</span> <span class="sr">/([\\\*\{\}])/g</span><span class="p">,</span> <span class="s">&#39;\\\$1&#39;</span>


      <span class="nv">blockStartMatcher = </span><span class="sr">///^\s*(</span><span class="si">#{</span><span class="nx">blockStarts</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)(?:</span><span class="si">#{</span><span class="nx">blockLines</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)?(?:</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">(.*))?$///</span>
      <span class="nv">blockLineMatcher = </span> <span class="sr">///^\s*(</span><span class="si">#{</span><span class="nx">blockLines</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">(.*)$///</span>
      <span class="nv">blockEndMatcher = </span>  <span class="sr">///^\s*(?:</span><span class="si">#{</span><span class="nx">blockLines</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)?(.*)(</span><span class="si">#{</span><span class="nx">blockEnds</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)$///</span>

      <span class="nv">blockSingleLineMatcher = </span><span class="sr">///^\s*(</span><span class="si">#{</span><span class="nx">blockStarts</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">(.*)</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}</span><span class="sr">(</span><span class="si">#{</span><span class="nx">blockEnds</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)///</span>

      <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="o">?</span>
        <span class="nv">singleLineMatcher = </span><span class="sr">///</span><span class="si">#{</span><span class="nx">singleLineMatcher</span><span class="p">.</span><span class="nx">source</span><span class="si">}</span><span class="sr">|</span><span class="si">#{</span><span class="nx">blockSingleLineMatcher</span><span class="p">.</span><span class="nx">source</span><span class="si">}</span><span class="sr">///</span>
      <span class="k">else</span>
        <span class="nv">singleLineMatcher = </span><span class="nx">blockSingleLineMatcher</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">ignorePrefix</span><span class="o">?</span>
      <span class="nv">stripIgnorePrefix = </span><span class="sr">///(</span><span class="si">#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">ignorePrefix</span><span class="si">}</span><span class="sr">///</span>

    <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">foldPrefix</span><span class="o">?</span>
      <span class="nv">stripFoldPrefix = </span><span class="sr">///(</span><span class="si">#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;|&#39;</span><span class="si">}</span><span class="sr">)</span><span class="si">#{</span><span class="nx">whitespaceMatch</span><span class="si">}#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">foldPrefix</span><span class="si">}</span><span class="sr">///</span>

    <span class="nv">inBlock = </span><span class="kc">false</span>
    <span class="nv">inLiterateBlock = </span><span class="nx">isLiterateCode</span> <span class="o">is</span> <span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This flag indicates if the previous line was empty, hence literate code
must always be surrounded (or at least introduced) by an empty line, ie.
matching an empty string (<code>""</code>).  This is needed to distinguish code from
bullet-lists or the like, which may accidently match the start of a line
of code.  The initial value <code>true</code> allows us to immediately start with
code, although this is quite unusual.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">literateCodePossible = </span><span class="nx">isLiterateCode</span> <span class="o">is</span> <span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Now iterate over each line</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">lines</span>

      <span class="k">if</span> <span class="nx">isLiterateCode</span>
        <span class="k">if</span> <span class="nx">literateCodePossible</span> <span class="o">and</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">codeLineMatcher</span><span class="p">)</span><span class="o">?</span>
          <span class="nv">value = </span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="nx">match</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
          <span class="k">continue</span> <span class="k">if</span> <span class="o">not</span> <span class="nx">value</span><span class="o">?</span> <span class="o">or</span> <span class="nx">value</span> <span class="o">is</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The previous cycle contained literate comments - in literate mode
we absolutely want to separate code from comments into independent
segments, as overlapping will make no sense in most cases</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span> <span class="nx">inLiterateBlock</span> <span class="o">and</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
            <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

          <span class="nv">inLiterateBlock = </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Process the matching literate code as if it isn't literate, hence
we continue further processing of this line and therefore no
<code>continue</code>-statement occurs here.  Compare this to the following
<code>else</code>-statement</p></div></div><div class="code"><div class="wrapper">          <span class="nv">line = </span><span class="nx">value</span>

        <span class="k">else</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>code-block requires an introducing empty line,
also see<code>literateCodePossible</code> initialization above</p></div></div><div class="code"><div class="wrapper">          <span class="nv">literateCodePossible = </span><span class="nx">line</span> <span class="o">is</span> <span class="s">&#39;&#39;</span>

          <span class="k">unless</span> <span class="nx">inLiterateBlock</span>
            <span class="nv">inLiterateBlock = </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>From the previous cycle are comments left not being literate,
so let's start a new segment</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
              <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The previous cycle contained literate code,
so let's start a new segment, as in literate mode
we separate code from comments into independent
segments, as overlapping makes no sense in most cases</p></div></div><div class="code"><div class="wrapper">          <span class="k">else</span> <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
            <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

          <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we skip further processing this line, as if <code>commentsOnly</code> is true</p></div></div><div class="code"><div class="wrapper">          <span class="k">continue</span>

      <span class="k">if</span> <span class="nx">inBlock</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">blockEndMatcher</span><span class="p">)</span><span class="o">?</span>
          <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="nv">inBlock = </span><span class="kc">false</span>

        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">blockLineMatcher</span><span class="p">)</span><span class="o">?</span>
          <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">else</span>
          <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match that line to the language's multi line comment syntax, if it exists</p></div></div><div class="code"><div class="wrapper">      <span class="k">else</span> <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span><span class="o">?</span> <span class="o">and</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">blockStartMatcher</span><span class="p">)</span><span class="o">?</span>

        <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
          <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
          <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

        <span class="k">if</span> <span class="nx">line</span><span class="p">[</span><span class="nx">line</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">language</span><span class="p">.</span><span class="nx">foldPrefix</span>
          <span class="nv">currSegment.hide = </span><span class="kc">yes</span>

        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="nv">inBlock = </span><span class="kc">true</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Match that line to the language's single line comment syntax.
However, we treat all comments beginning with } as inline code commentary
and comments starting with - cause that comment and the following code
block to start folded.</p></div></div><div class="code"><div class="wrapper">      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">singleLineMatcher</span><span class="p">)</span><span class="o">?</span>

        <span class="nv">value = </span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="nx">match</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>

        <span class="k">if</span> <span class="nx">value</span><span class="o">?</span> <span class="o">and</span> <span class="nx">value</span> <span class="o">isnt</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">          <span class="c1"># For example, this comment should be treated as part of our code.</span>
          <span class="c1"># Achieved by prefixing the comment&#39;s content with “}”</span>
          <span class="k">if</span> <span class="nx">stripIgnorePrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">value</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">language</span><span class="p">.</span><span class="nx">ignorePrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Unfold this code -></strong></p></div></div><div class="code folded"><div class="marker wrapper"><span class="c1">            # The previous cycle contained code, so lets start a new segment,</span></div><div class="wrapper">            <span class="c1"># but only if the previous code-line isn&#39;t a comment forced to be</span>
            <span class="c1"># part of the code, as implemented here.  This allows embedding a</span>
            <span class="c1"># series of code-comments, even folded like this one.</span>
            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">and</span> <span class="o">\</span>
               <span class="o">not</span> <span class="p">(</span><span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">match</span> <span class="nx">singleLineMatcher</span><span class="p">)</span><span class="o">?</span>
              <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
              <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “}” character from our documentation</p></div></div><div class="code"><div class="wrapper">            <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">stripIgnorePrefix</span><span class="p">,</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

          <span class="k">else</span> </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The previous cycle contained code, so lets start a new segment</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
              <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="code folded"><div class="marker wrapper"><span class="c1">            # … if we start this comment with “-” instead of “}” it and all</span></div><div class="wrapper">            <span class="c1"># code up to the next segment&#39;s first comment starts folded</span>
            <span class="k">if</span> <span class="nx">stripFoldPrefix</span><span class="o">?</span> <span class="o">and</span> <span class="nx">value</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">language</span><span class="p">.</span><span class="nx">foldPrefix</span><span class="p">)</span> <span class="o">is</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">              <span class="c1"># … so folding stopped above, as this is a new segment !</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let's strip the “-” character in our documentation</p></div></div><div class="code"><div class="wrapper">              <span class="nv">currSegment.foldMarker = </span><span class="nx">line</span><span class="p">.</span><span class="nx">replace</span> <span class="nx">stripFoldPrefix</span><span class="p">,</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">else</span>
              <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">value</span>

      <span class="k">else</span>
        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

    <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>

    <span class="nx">segments</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Just a convenient prototype for building segments</p></div></div><div class="code"><div class="wrapper">  <span class="nv">Segment: </span><span class="k">class</span> <span class="nx">Segment</span>
    <span class="nv">constructor: </span><span class="nf">(code=[], comments=[], foldMarker=&#39;&#39;) -&gt;</span>
      <span class="vi">@code     = </span><span class="nx">code</span>
      <span class="vi">@comments = </span><span class="nx">comments</span>
      <span class="vi">@foldMarker = </span><span class="nx">foldMarker</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annotate an array of segments by running their code through <a href="http://pygments.org/">Pygments</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">highlightCode: </span><span class="nf">(segments, language, callback) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don't bother spawning pygments if we have nothing to highlight</p></div></div><div class="code"><div class="wrapper">    <span class="nv">numCodeLines = </span><span class="nx">segments</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span> <span class="nf">(c,s) -&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="p">),</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">numCodeLines</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="nx">segment</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="s">&#39;&#39;</span>

      <span class="k">return</span> <span class="nx">callback</span><span class="p">()</span>

    <span class="nv">errListener = </span><span class="nf">(error) -&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This appears to only occur when pygmentize is missing:</p></div></div><div class="code"><div class="wrapper">      <span class="nx">Logger</span><span class="p">.</span><span class="nx">error</span> <span class="s">&quot;Unable to find &#39;pygmentize&#39; on your PATH.  Please install pygments.&quot;</span>
      <span class="nx">Logger</span><span class="p">.</span><span class="nx">info</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Lack of pygments is a one time setup task, we don't feel bad about killing the process
off until the user does so.  It's a hard requirement.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span> <span class="mi">1</span>

    <span class="nv">pygmentize = </span><span class="nx">childProcess</span><span class="p">.</span><span class="nx">spawn</span> <span class="s">&#39;pygmentize&#39;</span><span class="p">,</span> <span class="p">[</span>
      <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="nx">language</span><span class="p">.</span><span class="nx">pygmentsLexer</span>
      <span class="s">&#39;-f&#39;</span><span class="p">,</span> <span class="s">&#39;html&#39;</span>
      <span class="s">&#39;-O&#39;</span><span class="p">,</span> <span class="s">&#39;encoding=utf-8,tabsize=2&#39;</span>
    <span class="p">]</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stderr</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data)  -&gt;</span> <span class="nx">callback</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="nx">errListener</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">on</span> <span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="nx">errListener</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We'll just split the output at the end.  pygmentize doesn't stream its output, and a given
source file is small enough that it shouldn't matter.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data) =&gt;</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>v0.8 changed exit/close event semantics.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">match = </span><span class="nx">process</span><span class="p">.</span><span class="nx">version</span><span class="p">.</span><span class="nx">match</span> <span class="sr">/v(\d+\.\d+)/</span>
    <span class="nv">closeEvent = </span><span class="k">if</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.8</span> <span class="k">then</span> <span class="s">&#39;exit&#39;</span> <span class="k">else</span> <span class="s">&#39;close&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We can't include either of the following words ANYWHERE directly adjacent to each other
Otherwise, our regex (~10 lines below) will split on them, and the number of code blocks
and comment blocks will not be equal.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">seg = </span><span class="s">&#39;SEGMENT&#39;</span>
    <span class="nv">div = </span><span class="s">&#39;DIVIDER&#39;</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">addListener</span> <span class="nx">closeEvent</span><span class="p">,</span> <span class="nf">(args...) =&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>pygments spits it out wrapped in <code>&lt;div class="highlight"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</code>.  We want to
manage the styling ourselves, so remove that.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">result = </span><span class="nx">result</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;/pre&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extract our segments from the pygmentized source.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">highlighted = </span><span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">result</span><span class="si">}</span><span class="s">\n&quot;</span><span class="p">.</span><span class="nx">split</span> <span class="sr">///.*&lt;span.*</span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="sr">\s</span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="sr">.*&lt;\/span&gt;.*///</span>

      <span class="k">if</span> <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

        <span class="nv">error = </span><span class="k">new</span> <span class="nb">Error</span> <span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">format</span> <span class="s">&#39;pygmentize rendered %d of %d segments; expected to be equal&#39;</span><span class="p">,</span>
          <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>

        <span class="nv">error.pygmentsOutput   = </span><span class="nx">result</span>
        <span class="nv">error.failedHighlights = </span><span class="nx">highlighted</span>
        <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach highlighted source to the highlightedCode property of a Segment.</p></div></div><div class="code"><div class="wrapper">      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="nx">highlighted</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Rather than spawning pygments for each segment, we stream it all in, separated by 'magic'
comments so that we can split the highlighted source back into segments.
To further complicate things, pygments doesn't let us cheat with indentation-aware languages:
We have to match the indentation of the line following the divider comment.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">mergedCode = </span><span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
      <span class="nv">segmentCode = </span><span class="nx">segment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>

      <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Double negative: match characters that are spaces but not newlines</p></div></div><div class="code"><div class="wrapper">        <span class="nv">indentation = </span><span class="nx">segmentCode</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^[^\S\n]+/</span><span class="p">)</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="o">?</span>
          <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">indentation</span><span class="si">}#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="s">\n&quot;</span>
        <span class="k">else</span>
          <span class="nv">mlc = </span><span class="nx">language</span><span class="p">.</span><span class="nx">multiLineComment</span>
          <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">indentation</span><span class="si">}#{</span><span class="nx">mlc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">seg</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">div</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">mlc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s">\n&quot;</span>

      <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="nx">segmentCode</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">write</span> <span class="nx">mergedCode</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>

  <span class="nv">parseDocTags: </span><span class="nf">(segments, project, fileInfo, callback) -&gt;</span>
    
    <span class="nv">DOC_TAGS = </span><span class="k">if</span> <span class="nx">fileInfo</span><span class="o">?</span><span class="p">.</span><span class="nx">language</span><span class="p">.</span><span class="nx">doctags</span><span class="o">?</span> <span class="k">then</span> <span class="nx">fileInfo</span><span class="p">.</span><span class="nx">language</span><span class="p">.</span><span class="nx">doctags</span> <span class="k">else</span> <span class="kc">null</span>

    <span class="nv">TAG_REGEX = </span><span class="sr">/(?:^|\s)@(\w+)(?:\s+(.*))?/</span>
    <span class="nv">TAG_VALUE_REGEX = </span><span class="sr">/^(?:&quot;(.*)&quot;|&#39;(.*)&#39;|\{(.*)\}|(.*))$/</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span> <span class="k">when</span> <span class="nx">TAG_REGEX</span><span class="p">.</span><span class="nx">test</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;\n&#39;</span><span class="p">)</span>
        <span class="nv">tags = </span><span class="p">[]</span>
        <span class="nv">currTag = </span><span class="p">{</span>
          <span class="nv">name: </span><span class="s">&#39;description&#39;</span>
          <span class="nv">value: </span><span class="s">&#39;&#39;</span>
        <span class="p">}</span>
        <span class="nx">tags</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currTag</span>
        <span class="nv">tagSections = </span><span class="p">{}</span>

        <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span> <span class="k">when</span> <span class="nx">line</span><span class="o">?</span>
          <span class="k">if</span> <span class="nx">DOC_TAGS</span><span class="o">?</span> <span class="o">and</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">TAG_REGEX</span><span class="p">)</span><span class="o">?</span>
            <span class="nv">currTag = </span><span class="p">{</span>
              <span class="nv">name: </span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
              <span class="nv">value: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="s">&#39;&#39;</span>
            <span class="p">}</span>
            <span class="nx">tags</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currTag</span>
          <span class="k">else</span>
            <span class="nx">currTag</span><span class="p">.</span><span class="nx">value</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">line</span><span class="si">}</span><span class="s">&quot;</span>

        <span class="k">if</span> <span class="nx">DOC_TAGS</span><span class="o">?</span>
          <span class="k">for</span> <span class="nx">tag</span> <span class="k">in</span> <span class="nx">tags</span>
            <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/^\n|\n$/g</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

            <span class="nv">tagDefinition = </span><span class="nx">DOC_TAGS</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span>

            <span class="k">unless</span> <span class="nx">tagDefinition</span><span class="o">?</span>
              <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="nv">tagDefinition = </span><span class="s">&#39;defaultNoValue&#39;</span>
              <span class="k">else</span>
                <span class="nv">tagDefinition = </span><span class="s">&#39;defaultHasValue&#39;</span>

            <span class="k">if</span> <span class="s">&#39;string&#39;</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">tagDefinition</span>
              <span class="nv">tagDefinition = </span><span class="nx">DOC_TAGS</span><span class="p">[</span><span class="nx">tagDefinition</span><span class="p">]</span>

            <span class="nv">tag.definition = </span><span class="nx">tagDefinition</span>
            <span class="nv">tag.section = </span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">section</span>

            <span class="k">if</span> <span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">valuePrefix</span><span class="o">?</span>
              <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">///</span><span class="si">#{</span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">valuePrefix</span><span class="o">?</span><span class="si">}</span><span class="sr">\s+///</span><span class="p">,</span> <span class="s">&#39;&#39;</span>

            <span class="k">if</span> <span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">parseValue</span><span class="o">?</span>
              <span class="nv">tag.value = </span><span class="nx">tagDefinition</span><span class="p">.</span><span class="nx">parseValue</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">not</span> <span class="sr">/\n/</span><span class="p">.</span><span class="nx">test</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
              <span class="nv">tag.value = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">TAG_VALUE_REGEX</span><span class="p">)[</span><span class="mi">1</span><span class="p">..].</span><span class="nx">join</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>

            <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">unless</span> <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">]</span><span class="o">?</span>
            <span class="nx">tagSections</span><span class="p">[</span><span class="nx">tag</span><span class="p">.</span><span class="nx">section</span><span class="p">].</span><span class="nx">push</span> <span class="nx">tag</span>

        <span class="nv">segment.tags = </span><span class="nx">tags</span>
        <span class="nv">segment.tagSections = </span><span class="nx">tagSections</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span>

  <span class="nv">markdownDocTags: </span><span class="nf">(segments, project, fileInfo, callback) -&gt;</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span> <span class="k">when</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">tags</span><span class="o">?</span>

        <span class="k">for</span> <span class="nx">tag</span> <span class="k">in</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">tags</span>
          <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="o">?</span>
            <span class="k">if</span> <span class="s">&#39;string&#39;</span> <span class="o">==</span> <span class="k">typeof</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\{value\}/g</span><span class="p">,</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>a {type} is an automatically linked {value}</p></div></div><div class="code"><div class="wrapper">              <span class="k">if</span> <span class="sr">/\{type\}/</span><span class="p">.</span><span class="nx">test</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span>
                <span class="k">if</span> <span class="nx">fileInfo</span><span class="o">?</span><span class="p">.</span><span class="nx">language</span><span class="p">.</span><span class="nx">namespace</span><span class="o">?</span>
                  <span class="nv">type = </span><span class="nx">DOCTAGHelpers</span><span class="p">.</span><span class="nx">link_type</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fileInfo</span>
                <span class="k">else</span>
                  <span class="nv">type = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span>
                <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">markdown</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\{type\}/g</span><span class="p">,</span> <span class="nx">type</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the value is empty, strip the empty suffix.  The simpler
<code>tag.markdown.replace / \*\*$/, ''</code> erroneously fails </p></div></div><div class="code"><div class="wrapper">              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">markdown</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/// \*\*$///</span><span class="p">,</span> <span class="s">&#39;&#39;</span>
            <span class="k">else</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">definition</span><span class="p">.</span><span class="nx">markdown</span><span class="p">(</span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fileInfo</span><span class="p">)</span>
          <span class="k">else</span>
            <span class="k">if</span> <span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
              <span class="nv">tag.markdown = </span><span class="s">&quot;</span><span class="si">#{</span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="s"> </span><span class="si">#{</span><span class="nx">tag</span><span class="p">.</span><span class="nx">value</span><span class="si">}</span><span class="s">&quot;</span>
            <span class="k">else</span>
              <span class="nv">tag.markdown = </span><span class="nx">tag</span><span class="p">.</span><span class="nx">name</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Annotate an array of segments by running their comments through
<a href="https://github.com/coreyti/showdown">showdown</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">markdownComments: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">converter = </span><span class="k">new</span> <span class="nx">showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">(</span><span class="nv">extensions: </span><span class="nx">project</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">showdown</span><span class="p">)</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">markdown = </span><span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>
        <span class="nv">headers  = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>showdown generates header ids by lowercasing &amp; dropping non-word characters.  We'd like
something a bit more readable.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">markdown = </span><span class="nx">@gsub</span> <span class="nx">markdown</span><span class="p">,</span> <span class="sr">/&lt;h(\d) id=&quot;[^&quot;]+&quot;&gt;([^&lt;]+)&lt;\/h\d&gt;/g</span><span class="p">,</span> <span class="nf">(match) =&gt;</span>
          <span class="nv">header =</span>
            <span class="nv">level: </span><span class="nb">parseInt</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nv">title: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="nv">slug: </span> <span class="nx">@slugifyTitle</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

          <span class="nv">header.isFileHeader = </span><span class="kc">true</span> <span class="k">if</span> <span class="nx">header</span><span class="p">.</span><span class="nx">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">segmentIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span>

          <span class="nx">headers</span><span class="p">.</span><span class="nx">push</span> <span class="nx">header</span>

          <span class="s">&quot;&lt;h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s"> id=\&quot;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">slug</span><span class="si">}</span><span class="s">\&quot;&gt;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="s">&lt;/h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s">&gt;&quot;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We attach the rendered markdown to the comment</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.markdownedComments = </span><span class="nx">markdown</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>As well as the extracted headers to aid in outline building.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.headers = </span><span class="nx">headers</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sometimes you just don't want any of them hanging around.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">trimBlankLines: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[\r\n]+/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\r\n]+$/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a title, convert it into a URL-friendly slug.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">slugifyTitle: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\s\-\_]+/</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span> <span class="nf">(s) -&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w]/g</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">).</span><span class="nx">join</span> <span class="s">&#39;-&#39;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>replacer is a function that is given the match object, and returns the string to replace with.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">gsub: </span><span class="nf">(string, matcher, replacer) -&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="s">&#39;You must pass a global RegExp to gsub!&#39;</span> <span class="k">unless</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">global</span><span class="o">?</span>

    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nv">matcher.lastIndex = </span><span class="mi">0</span>
    <span class="nv">furthestIndex = </span><span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">exec</span> <span class="nx">string</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...</span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">replacer</span> <span class="nx">match</span>

      <span class="nv">furthestIndex = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">lastIndex</span>

    <span class="nx">result</span> <span class="o">+</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...]</span></div></div></div></div></body></html>